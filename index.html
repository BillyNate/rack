<html>
	<head>
		<title>Rack</title>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width">
		<style type="text/css">
			html, body { width: 100%; height: 100%; padding: 0; margin: 0; }
		</style>
		<script src="//cdn.jsdelivr.net/npm/gun/gun.js"></script>
		<script src="//cdn.jsdelivr.net/npm/gun/lib/open.js"></script>
		<script src="//unpkg.com/force-graph"></script>
		<script>
			// Create a hack to get all existing items from localStorage:
			Gun.getAll = function()
			{
				// Mostly copied over from localStorage code
				try{store = Gun.window.localStorage}catch(e){};
				if(!store)
				{
					store = {setItem: function(k,v){this[k]=v}, removeItem: function(k){delete this[k]}, getItem: function(k){return this[k]}};
				}

				let prefix = 'gun/';
				let gap = Gun.obj.ify(store.getItem('gap/' + prefix)) || {};
				let disk = Gun.obj.ify(store.getItem(prefix));

				return disk;
			};
		</script>
		<script>
			document.addEventListener('DOMContentLoaded', function(event)
			{
				// Initialize objects:
				const forceGraph = ForceGraph()(document.getElementById('graph'));
				window.gunDB = Gun({ localStorage: true }); // Currently attached to window, to easily access from browser console
				var graphData = {
					nodes: [],
					links: []
				},
					openedNodeGraphData = {
					nodes: [],
					links: []
				};
				let highlightNodes = [],
					highlightNode = null,
					openedNode = null,
    				highlightLink = null;
				var gunKeys = [],
					gunSouls = [],
					gunRefs = { exist: {}, setup: {} };

				// Configure the ForceGraph:
				forceGraph.d3Force('link').distance(link => 50);
				forceGraph
					.nodeId('#')
					.nodeLabel('#')
					.nodeRelSize(19)
					.linkSource('source')
					.linkTarget('target')
					.linkDirectionalParticles(1)
					.onLinkHover(link =>
					{
						highlightLink = link;
						highlightNodes = link ? [link.source, link.target] : [];
					})
					.linkCanvasObjectMode(() => 'after')
					.linkCanvasObject((link, ctx, globalScale) =>
					{
						if(link == highlightLink)
						{
							const start = link.source;
							const end = link.target;
							
							// calculate label positioning
							const textPos = Object.assign(...['x', 'y'].map(c => (
							{
								[c]: link.source[c] + (link.target[c] - link.source[c]) / 2 // calc middle point
							})));

							// estimate fontSize to fit in link length
							const fontSize = 17 / globalScale;
							ctx.font = fontSize + 'px Sans-Serif';
							const textWidth = ctx.measureText(link.label).width;

							// draw text label
							ctx.save();
							ctx.translate(textPos.x, textPos.y);

							ctx.textAlign = 'center';
							ctx.textBaseline = 'middle';
							ctx.fillStyle = '#666666';
							ctx.fillText(link.label, 0, 0);
							ctx.restore();
						}
					})
					.nodeCanvasObject((node, ctx, globalScale) =>
					{
						const fontSize = 17 / globalScale;
						ctx.font = fontSize + 'px Sans-Serif';
						const textWidth = ctx.measureText(node.label).width;

						ctx.textAlign = 'center';
						ctx.textBaseline = 'middle';
						ctx.fillStyle = 'rgba(30, 144, 255, .7)';
						if(highlightNodes.indexOf(node) >= 0 || highlightNode == node || openedNode == node || node.type == 'attr')
						{
							ctx.fillStyle = 'rgba(65, 105, 225, 1)';
						}
						ctx.fillText(node.label, node.x, node.y);
					})
					.onNodeHover(node =>
					{
						document.getElementById('graph').style.cursor = node ? 'pointer' : null;
						highlightNode = node;
					})
					.onNodeClick(node =>
					{
						if(node == openedNode)
						{
							openedNode = null;
							openedNodeGraphData.nodes = [];
							openedNodeGraphData.links = [];
							forceGraph.graphData(graphData);
						}
						else if(node.type == 'node')
						{
							openedNode = node;
							openedNodeGraphData.nodes = [];
							openedNodeGraphData.links = [];
							Object.keys(node.attributes).forEach(function(attributeKey)
							{
								openedNodeGraphData.nodes.push({  type: 'attr', '#': attributeKey, 'label': attributeKey + ': ' + node.attributes[attributeKey]  });
								openedNodeGraphData.links.push({ 'source': node['#'], 'target': attributeKey, 'label': '' });
							});

							let completeGraphData = { nodes: [], links: [] };
							completeGraphData.nodes = graphData.nodes.concat(openedNodeGraphData.nodes);
							completeGraphData.links = graphData.links.concat(openedNodeGraphData.links);
							forceGraph.graphData(completeGraphData);
						}
					})
					.onBackgroundClick(() =>
					{
						openedNode = null;
						openedNodeGraphData.nodes = [];
						openedNodeGraphData.links = [];
						forceGraph.graphData(graphData);
					});
				
				// Prepare listener function:
				function onNodeChange(data, nodeKey)
				{
					let i = graphData.nodes.findIndex((node) => node['#'] == nodeKey);
					if(i < 0)
					{
						i = graphData.nodes.push({ type: 'node', '#': nodeKey, 'label': nodeKey.substring(0, 5) + (nodeKey.length > 5 ? 'â€¦' : '') }) - 1;
					}

					// Go over all attributes:
					Object.keys(data).forEach(function(attrKey)
					{
						// Add link if target node exists:
						if(data[attrKey] !== null && typeof data[attrKey] === 'object')
						{
							if(data[attrKey]['#'] && data[attrKey]['#'] != nodeKey)
							{
								if(gunRefs.exist[nodeKey])
								{
									if(gunRefs.exist[nodeKey][data[attrKey]['#']])
									{
										return;
									}
								}

								if(gunSouls.indexOf(data[attrKey]['#']) >= 0)
								{
									graphData.links.push({ 'source': nodeKey, 'target': data[attrKey]['#'], label: attrKey });
									if(!gunRefs.exist[nodeKey])
									{
										gunRefs.exist[nodeKey] = {};
									}
									gunRefs.exist[nodeKey][data[attrKey]['#']] = { label: attrKey };
								}
								else
								{
									// If target nodes does not exist, add it to this array to handle later on:
									if(!gunRefs.setup[data[attrKey]['#']])
									{
										gunRefs.setup[data[attrKey]['#']] = {};
									}
									gunRefs.setup[data[attrKey]['#']][nodeKey] = { label: attrKey };
								}
							}
						}
						// Add as simple attribute:
						else if(typeof data[attrKey] === 'string')
						{
							if(!graphData.nodes[i]['attributes'])
							{
								graphData.nodes[i]['attributes'] = {};
							}
							graphData.nodes[i]['attributes'][attrKey] = data[attrKey];
						}
					});
					
					// Go over all links stashed in the gunRefs.setup to add them now that all nodes are added:
					if(gunRefs.setup[nodeKey])
					{
						let sourceNodes = Object.keys(gunRefs.setup[nodeKey]);

						while(sourceNodes.length > 0) // Assume all nodes in the array still exist
						{
							let sourceNode = gunRefs.setup[nodeKey][sourceNodes[0]]; // Currently handling this node...
							graphData.links.push({ 'source': sourceNodes[0], 'target': nodeKey, label: sourceNode.label });
							if(!gunRefs.exist[sourceNode])
							{
								gunRefs.exist[sourceNode] = {};
							}
							gunRefs.exist[sourceNode][sourceNodes[0]] = { label: sourceNode.label };
							
							sourceNodes.splice(0, 1);
							delete gunRefs.setup[nodeKey][sourceNodes[0]];
						}
						delete gunRefs.setup[nodeKey];
					}
					
					let completeGraphData = { nodes: [], links: [] };
					completeGraphData.nodes = graphData.nodes.concat(openedNodeGraphData.nodes);
					completeGraphData.links = graphData.links.concat(openedNodeGraphData.links);
					forceGraph.graphData(completeGraphData);
				}
				
				// Walk through all nodes found in graph:
				function processGraph(graph)
				{
					graph = graph || gunDB._.graph;
					gunKeys = Object.keys(graph);
					gunKeys.forEach(function(nodeKey)
					{
						// Keep track of already processed nodes/souls:
						if(gunSouls.indexOf(graph[nodeKey]['_']['#']) < 0)
						{
							// Attach listener to node:
							gunDB.get(nodeKey).on(onNodeChange);
							gunSouls.push(graph[nodeKey]['_']['#']);
						}
					});
				}
				
				// Use our hack to get existing nodes from localStorage:
				processGraph(Gun.getAll());

				// Another hack?: register listener for any new node:
				gunDB._.root.on('put', function(at)
				{
					Object.keys(at.put).forEach(function(putKey)
					{
						if(gunSouls.indexOf(putKey) < 0)
						{
							gunDB.get(putKey).on(onNodeChange);
							gunSouls.push(putKey);
						}
					});
				});

				let checkForChanges = setInterval(function()
				{
					let currentGunKeys = Object.keys(gunDB._.graph);
					if(gunKeys.join(',') != currentGunKeys.join(','))
					{
						processGraph();
						gunKeys = currentGunKeys;
					}
				}, 5000);
			});
		</script>
	</head>
	<body>
		<div id="graph"></div>
	</body>
</html>